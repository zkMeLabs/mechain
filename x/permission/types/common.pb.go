// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mechain/permission/common.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	common "github.com/evmos/evmos/v12/types/common"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ActionType defines the operations you can execute in mechain storage network
type ActionType int32

const (
	ACTION_UNSPECIFIED           ActionType = 0
	ACTION_UPDATE_BUCKET_INFO    ActionType = 1
	ACTION_DELETE_BUCKET         ActionType = 2
	ACTION_CREATE_OBJECT         ActionType = 3
	ACTION_DELETE_OBJECT         ActionType = 4
	ACTION_COPY_OBJECT           ActionType = 5
	ACTION_GET_OBJECT            ActionType = 6
	ACTION_EXECUTE_OBJECT        ActionType = 7
	ACTION_LIST_OBJECT           ActionType = 8
	ACTION_UPDATE_GROUP_MEMBER   ActionType = 9
	ACTION_DELETE_GROUP          ActionType = 10
	ACTION_UPDATE_OBJECT_INFO    ActionType = 11
	ACTION_UPDATE_GROUP_EXTRA    ActionType = 12
	ACTION_UPDATE_GROUP_INFO     ActionType = 13
	ACTION_UPDATE_OBJECT_CONTENT ActionType = 14
	ACTION_TYPE_ALL              ActionType = 99
)

var ActionType_name = map[int32]string{
	0:  "ACTION_UNSPECIFIED",
	1:  "ACTION_UPDATE_BUCKET_INFO",
	2:  "ACTION_DELETE_BUCKET",
	3:  "ACTION_CREATE_OBJECT",
	4:  "ACTION_DELETE_OBJECT",
	5:  "ACTION_COPY_OBJECT",
	6:  "ACTION_GET_OBJECT",
	7:  "ACTION_EXECUTE_OBJECT",
	8:  "ACTION_LIST_OBJECT",
	9:  "ACTION_UPDATE_GROUP_MEMBER",
	10: "ACTION_DELETE_GROUP",
	11: "ACTION_UPDATE_OBJECT_INFO",
	12: "ACTION_UPDATE_GROUP_EXTRA",
	13: "ACTION_UPDATE_GROUP_INFO",
	14: "ACTION_UPDATE_OBJECT_CONTENT",
	99: "ACTION_TYPE_ALL",
}

var ActionType_value = map[string]int32{
	"ACTION_UNSPECIFIED":           0,
	"ACTION_UPDATE_BUCKET_INFO":    1,
	"ACTION_DELETE_BUCKET":         2,
	"ACTION_CREATE_OBJECT":         3,
	"ACTION_DELETE_OBJECT":         4,
	"ACTION_COPY_OBJECT":           5,
	"ACTION_GET_OBJECT":            6,
	"ACTION_EXECUTE_OBJECT":        7,
	"ACTION_LIST_OBJECT":           8,
	"ACTION_UPDATE_GROUP_MEMBER":   9,
	"ACTION_DELETE_GROUP":          10,
	"ACTION_UPDATE_OBJECT_INFO":    11,
	"ACTION_UPDATE_GROUP_EXTRA":    12,
	"ACTION_UPDATE_GROUP_INFO":     13,
	"ACTION_UPDATE_OBJECT_CONTENT": 14,
	"ACTION_TYPE_ALL":              99,
}

func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}

func (ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1a6c95de065364c3, []int{0}
}

// Effect define the effect of the operation permission, include Allow or deny
type Effect int32

const (
	EFFECT_UNSPECIFIED Effect = 0
	EFFECT_ALLOW       Effect = 1
	EFFECT_DENY        Effect = 2
)

var Effect_name = map[int32]string{
	0: "EFFECT_UNSPECIFIED",
	1: "EFFECT_ALLOW",
	2: "EFFECT_DENY",
}

var Effect_value = map[string]int32{
	"EFFECT_UNSPECIFIED": 0,
	"EFFECT_ALLOW":       1,
	"EFFECT_DENY":        2,
}

func (x Effect) String() string {
	return proto.EnumName(Effect_name, int32(x))
}

func (Effect) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1a6c95de065364c3, []int{1}
}

// PrincipalType refers to the identity type of system users or entities.
// In Mechain, it usually refers to accounts or groups.
type PrincipalType int32

const (
	PRINCIPAL_TYPE_UNSPECIFIED  PrincipalType = 0
	PRINCIPAL_TYPE_GNFD_ACCOUNT PrincipalType = 1
	PRINCIPAL_TYPE_GNFD_GROUP   PrincipalType = 2
)

var PrincipalType_name = map[int32]string{
	0: "PRINCIPAL_TYPE_UNSPECIFIED",
	1: "PRINCIPAL_TYPE_GNFD_ACCOUNT",
	2: "PRINCIPAL_TYPE_GNFD_GROUP",
}

var PrincipalType_value = map[string]int32{
	"PRINCIPAL_TYPE_UNSPECIFIED":  0,
	"PRINCIPAL_TYPE_GNFD_ACCOUNT": 1,
	"PRINCIPAL_TYPE_GNFD_GROUP":   2,
}

func (x PrincipalType) String() string {
	return proto.EnumName(PrincipalType_name, int32(x))
}

func (PrincipalType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1a6c95de065364c3, []int{2}
}

type Statement struct {
	// effect define the impact of permissions, which can be Allow/Deny
	Effect Effect `protobuf:"varint,1,opt,name=effect,proto3,enum=mechain.permission.Effect" json:"effect,omitempty"`
	// action_type define the operation type you can act. mechain defines a set of permission
	// that you can specify in a permissionInfo. see ActionType enum for detail.
	Actions []ActionType `protobuf:"varint,2,rep,packed,name=actions,proto3,enum=mechain.permission.ActionType" json:"actions,omitempty"`
	// CAN ONLY USED IN bucket level. Support fuzzy match and limit to 5.
	// The sub-resource name must comply with the standard specified in the mechain/types/grn.go file for Mechain resource names.
	// If the sub-resources include 'grn:o:{bucket_name}/*' in the statement, it indicates that specific permissions is granted to all objects within the specified bucket.
	// If the sub-resources include 'grn:o:{bucket_name}/test_*' in the statement, it indicates that specific permissions is granted to all objects with the `test_` prefix within the specified bucket.
	// If the sub-resources is empty, when you need to operate(excluding CreateObject) a specified subresource, it will be denied because it cannot match any subresource.
	Resources []string `protobuf:"bytes,3,rep,name=resources,proto3" json:"resources,omitempty"`
	// expiration_time defines how long the permission is valid. If not explicitly specified, it means it will not expire.
	ExpirationTime *time.Time `protobuf:"bytes,4,opt,name=expiration_time,json=expirationTime,proto3,stdtime" json:"expiration_time,omitempty"`
	// limit_size defines the total data size that is allowed to operate. If not explicitly specified, it means it will not limit.
	LimitSize *common.UInt64Value `protobuf:"bytes,5,opt,name=limit_size,json=limitSize,proto3" json:"limit_size,omitempty"`
}

func (m *Statement) Reset()         { *m = Statement{} }
func (m *Statement) String() string { return proto.CompactTextString(m) }
func (*Statement) ProtoMessage()    {}
func (*Statement) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a6c95de065364c3, []int{0}
}
func (m *Statement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Statement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Statement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Statement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Statement.Merge(m, src)
}
func (m *Statement) XXX_Size() int {
	return m.Size()
}
func (m *Statement) XXX_DiscardUnknown() {
	xxx_messageInfo_Statement.DiscardUnknown(m)
}

var xxx_messageInfo_Statement proto.InternalMessageInfo

func (m *Statement) GetEffect() Effect {
	if m != nil {
		return m.Effect
	}
	return EFFECT_UNSPECIFIED
}

func (m *Statement) GetActions() []ActionType {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *Statement) GetResources() []string {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Statement) GetExpirationTime() *time.Time {
	if m != nil {
		return m.ExpirationTime
	}
	return nil
}

func (m *Statement) GetLimitSize() *common.UInt64Value {
	if m != nil {
		return m.LimitSize
	}
	return nil
}

// Principal define the roles that can be grant permissions to. Currently, it can be account or group.
type Principal struct {
	Type PrincipalType `protobuf:"varint,1,opt,name=type,proto3,enum=mechain.permission.PrincipalType" json:"type,omitempty"`
	// When the type is an account, its value is sdk.AccAddress().String();
	// when the type is a group, its value is math.Uint().String()
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Principal) Reset()         { *m = Principal{} }
func (m *Principal) String() string { return proto.CompactTextString(m) }
func (*Principal) ProtoMessage()    {}
func (*Principal) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a6c95de065364c3, []int{1}
}
func (m *Principal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Principal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Principal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Principal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Principal.Merge(m, src)
}
func (m *Principal) XXX_Size() int {
	return m.Size()
}
func (m *Principal) XXX_DiscardUnknown() {
	xxx_messageInfo_Principal.DiscardUnknown(m)
}

var xxx_messageInfo_Principal proto.InternalMessageInfo

func (m *Principal) GetType() PrincipalType {
	if m != nil {
		return m.Type
	}
	return PRINCIPAL_TYPE_UNSPECIFIED
}

func (m *Principal) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterEnum("mechain.permission.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("mechain.permission.Effect", Effect_name, Effect_value)
	proto.RegisterEnum("mechain.permission.PrincipalType", PrincipalType_name, PrincipalType_value)
	proto.RegisterType((*Statement)(nil), "mechain.permission.Statement")
	proto.RegisterType((*Principal)(nil), "mechain.permission.Principal")
}

func init() { proto.RegisterFile("mechain/permission/common.proto", fileDescriptor_1a6c95de065364c3) }

var fileDescriptor_1a6c95de065364c3 = []byte{
	// 708 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0x4d, 0x6f, 0xda, 0x48,
	0x18, 0xc6, 0x40, 0x48, 0x78, 0x93, 0x10, 0xef, 0x24, 0xd9, 0x75, 0x08, 0x6b, 0xd8, 0x9c, 0x50,
	0xa4, 0xc5, 0x5a, 0xf6, 0x43, 0x7b, 0x5c, 0x63, 0x06, 0xe4, 0x2d, 0xb1, 0x2d, 0x63, 0xda, 0xa4,
	0x17, 0xcb, 0xb1, 0x26, 0xc4, 0x12, 0xc6, 0x96, 0x6d, 0xd2, 0x24, 0xbf, 0xa0, 0xc7, 0xfc, 0x87,
	0x5e, 0xfa, 0x47, 0x2a, 0xe5, 0x98, 0x63, 0x4f, 0x6d, 0x95, 0xfc, 0x91, 0xca, 0xf6, 0xf0, 0x55,
	0xb8, 0x20, 0xe6, 0x79, 0x9e, 0xf7, 0x99, 0xf7, 0x79, 0x67, 0xc6, 0x50, 0x75, 0x89, 0x7d, 0x6d,
	0x39, 0x63, 0xc1, 0x27, 0x81, 0xeb, 0x84, 0xa1, 0xe3, 0x8d, 0x05, 0xdb, 0x73, 0x5d, 0x6f, 0xdc,
	0xf0, 0x03, 0x2f, 0xf2, 0x10, 0xa2, 0x82, 0xc6, 0x5c, 0x50, 0x3e, 0xb2, 0xbd, 0xd0, 0xf5, 0x42,
	0x33, 0x51, 0x08, 0xe9, 0x22, 0x95, 0x97, 0x0f, 0x86, 0xde, 0xd0, 0x4b, 0xf1, 0xf8, 0x1f, 0x45,
	0xab, 0x43, 0xcf, 0x1b, 0x8e, 0x88, 0x90, 0xac, 0x2e, 0x27, 0x57, 0x42, 0xe4, 0xb8, 0x24, 0x8c,
	0x2c, 0xd7, 0xa7, 0x82, 0xca, 0xb4, 0x8d, 0x74, 0x6f, 0xe1, 0x5d, 0x60, 0xf9, 0x3e, 0x09, 0x52,
	0xf6, 0xe4, 0x63, 0x16, 0x8a, 0xfd, 0xc8, 0x8a, 0x88, 0x4b, 0xc6, 0x11, 0x6a, 0x42, 0x81, 0x5c,
	0x5d, 0x11, 0x3b, 0xe2, 0x98, 0x1a, 0x53, 0x2f, 0x35, 0xcb, 0x8d, 0xd5, 0x16, 0x1b, 0x38, 0x51,
	0xe8, 0x54, 0x89, 0xfe, 0x85, 0x4d, 0xcb, 0x8e, 0x1c, 0x6f, 0x1c, 0x72, 0xd9, 0x5a, 0xae, 0x5e,
	0x6a, 0xf2, 0xeb, 0x8a, 0xc4, 0x44, 0x62, 0xdc, 0xf9, 0x44, 0x9f, 0xca, 0x51, 0x05, 0x8a, 0x01,
	0x09, 0xbd, 0x49, 0x60, 0x93, 0x90, 0xcb, 0xd5, 0x72, 0xf5, 0xa2, 0x3e, 0x07, 0xd0, 0x19, 0xec,
	0x91, 0x5b, 0xdf, 0x09, 0xac, 0x58, 0x6c, 0xc6, 0xa9, 0xb8, 0x7c, 0x8d, 0xa9, 0x6f, 0x37, 0xcb,
	0x8d, 0x34, 0x72, 0x63, 0x1a, 0xb9, 0x61, 0x4c, 0x23, 0xb7, 0xb6, 0x1e, 0xbf, 0x54, 0x99, 0x87,
	0xaf, 0x55, 0x46, 0x2f, 0xcd, 0x8b, 0x63, 0x1a, 0xfd, 0x07, 0x30, 0x72, 0x5c, 0x27, 0x32, 0x43,
	0xe7, 0x9e, 0x70, 0x1b, 0x89, 0xd3, 0xf1, 0xac, 0x53, 0x7a, 0x2e, 0x03, 0x79, 0x1c, 0xfd, 0xf3,
	0xd7, 0x6b, 0x6b, 0x34, 0x21, 0xad, 0x7c, 0x6c, 0xa5, 0x17, 0x93, 0xa2, 0xbe, 0x73, 0x4f, 0x4e,
	0xce, 0xa1, 0xa8, 0x05, 0xce, 0xd8, 0x76, 0x7c, 0x6b, 0x84, 0xfe, 0x86, 0x7c, 0x74, 0xe7, 0x13,
	0x3a, 0xa7, 0xdf, 0xd6, 0x45, 0x9e, 0x89, 0x93, 0xd4, 0x89, 0x1c, 0x1d, 0xc0, 0xc6, 0x4d, 0xec,
	0xce, 0x65, 0x6b, 0x4c, 0xbd, 0xa8, 0xa7, 0x8b, 0xd3, 0x4f, 0x39, 0x80, 0xf9, 0x80, 0xd0, 0xcf,
	0x80, 0x44, 0xc9, 0x90, 0x55, 0xc5, 0x1c, 0x28, 0x7d, 0x0d, 0x4b, 0x72, 0x47, 0xc6, 0x6d, 0x36,
	0x83, 0x7e, 0x85, 0xa3, 0x29, 0xae, 0xb5, 0x45, 0x03, 0x9b, 0xad, 0x81, 0xf4, 0x0a, 0x1b, 0xa6,
	0xac, 0x74, 0x54, 0x96, 0x41, 0x1c, 0x1c, 0x50, 0xba, 0x8d, 0x7b, 0x78, 0x46, 0xb3, 0xd9, 0x05,
	0x46, 0xd2, 0x71, 0x5c, 0xa8, 0xb6, 0xfe, 0xc7, 0x92, 0xc1, 0xe6, 0x56, 0x6b, 0x28, 0x93, 0x5f,
	0x68, 0x42, 0x52, 0xb5, 0x8b, 0x29, 0xbe, 0x81, 0x0e, 0xe1, 0x27, 0x8a, 0x77, 0xb1, 0x31, 0x85,
	0x0b, 0xe8, 0x08, 0x0e, 0x29, 0x8c, 0xcf, 0xb1, 0x34, 0x98, 0x3b, 0x6d, 0x2e, 0x38, 0xf5, 0xe4,
	0xfe, 0xac, 0x64, 0x0b, 0xf1, 0x50, 0x5e, 0x8e, 0xd3, 0xd5, 0xd5, 0x81, 0x66, 0x9e, 0xe1, 0xb3,
	0x16, 0xd6, 0xd9, 0x22, 0xfa, 0x05, 0xf6, 0x97, 0x7b, 0x4b, 0x78, 0x16, 0x56, 0xe7, 0x90, 0x5a,
	0xa6, 0x73, 0xd8, 0x5e, 0xa5, 0x53, 0x5f, 0x7c, 0x6e, 0xe8, 0x22, 0xbb, 0x83, 0x2a, 0xc0, 0xad,
	0xa3, 0x93, 0xe2, 0x5d, 0x54, 0x83, 0xca, 0x5a, 0x6f, 0x49, 0x55, 0x0c, 0xac, 0x18, 0x6c, 0x09,
	0xed, 0xc3, 0x1e, 0x55, 0x18, 0x17, 0x1a, 0x36, 0xc5, 0x5e, 0x8f, 0xb5, 0xcb, 0xf9, 0xf7, 0x1f,
	0xf8, 0xcc, 0xa9, 0x0c, 0x85, 0xf4, 0x71, 0xc4, 0x99, 0x71, 0xa7, 0x13, 0x17, 0x2e, 0x1f, 0x21,
	0x0b, 0x3b, 0x14, 0x17, 0x7b, 0x3d, 0xf5, 0x0d, 0xcb, 0xa0, 0x3d, 0xd8, 0xa6, 0x48, 0x1b, 0x2b,
	0x17, 0x6c, 0x96, 0x5a, 0x4d, 0x60, 0x77, 0xe9, 0xfe, 0xc4, 0xd3, 0xd2, 0x74, 0x59, 0x91, 0x64,
	0x4d, 0xec, 0xa5, 0x3b, 0x2f, 0x3b, 0x57, 0xe1, 0xf8, 0x07, 0xbe, 0xab, 0x74, 0xda, 0xa6, 0x28,
	0x49, 0xea, 0x40, 0x31, 0x58, 0x26, 0x1e, 0xcb, 0x3a, 0x41, 0x3a, 0x54, 0xba, 0x6d, 0xab, 0xfb,
	0xf8, 0xcc, 0x33, 0x4f, 0xcf, 0x3c, 0xf3, 0xed, 0x99, 0x67, 0x1e, 0x5e, 0xf8, 0xcc, 0xd3, 0x0b,
	0x9f, 0xf9, 0xfc, 0xc2, 0x67, 0xde, 0xfe, 0x3e, 0x74, 0xa2, 0xeb, 0xc9, 0x65, 0xfc, 0x52, 0x04,
	0x72, 0xe3, 0x7a, 0x21, 0xfd, 0xbd, 0xf9, 0xa3, 0x29, 0xdc, 0x2e, 0x7e, 0xe2, 0xe2, 0x7b, 0x1e,
	0x5e, 0x16, 0x92, 0xc7, 0xf9, 0xe7, 0xf7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x17, 0x93, 0x6f,
	0x05, 0x05, 0x00, 0x00,
}

func (m *Statement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Statement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Statement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LimitSize != nil {
		{
			size, err := m.LimitSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCommon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ExpirationTime != nil {
		n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ExpirationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpirationTime):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintCommon(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Resources[iNdEx])
			copy(dAtA[i:], m.Resources[iNdEx])
			i = encodeVarintCommon(dAtA, i, uint64(len(m.Resources[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Actions) > 0 {
		dAtA4 := make([]byte, len(m.Actions)*10)
		var j3 int
		for _, num := range m.Actions {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintCommon(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Effect != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Effect))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Principal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Principal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Principal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Statement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Effect != 0 {
		n += 1 + sovCommon(uint64(m.Effect))
	}
	if len(m.Actions) > 0 {
		l = 0
		for _, e := range m.Actions {
			l += sovCommon(uint64(e))
		}
		n += 1 + sovCommon(uint64(l)) + l
	}
	if len(m.Resources) > 0 {
		for _, s := range m.Resources {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.ExpirationTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpirationTime)
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.LimitSize != nil {
		l = m.LimitSize.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *Principal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCommon(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Statement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			m.Effect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Effect |= Effect(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v ActionType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ActionType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Actions = append(m.Actions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCommon
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCommon
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Actions) == 0 {
					m.Actions = make([]ActionType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ActionType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ActionType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Actions = append(m.Actions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTime == nil {
				m.ExpirationTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ExpirationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LimitSize == nil {
				m.LimitSize = &common.UInt64Value{}
			}
			if err := m.LimitSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Principal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Principal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Principal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PrincipalType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
